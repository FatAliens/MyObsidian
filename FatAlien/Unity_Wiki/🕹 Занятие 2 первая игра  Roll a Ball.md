> [!warning] Перед началом смотри [создание проекта](./#sozdanie-svoego-pervogo-proekta)

## Идея

Сделаем простую игру где можно будет двигать шар :soccer: по горизонтали и вертикали чтобы подбирать раскиданные по локации кубики :ice_cube: и ограничить его передвижение стенами.

## Создание уровня

Нам нужно создать на сцене несколько кубов, трансформировать их и расставить их по уровню

> [!info] Сцена - это контейнер, в котором находятся все игровые объекты на уровне

По умолчанию у нас уже открыта сцена под названием <code>SampleScene.</code>
Все объекты на сцене в виде иерархии можно увидеть в окне Hierarhy в левой части экрана, там уже создано два объекта: **Main Camera** (_камера, из которой игрок видит локацию_) и **Directional Light** (_глобальное освещение которое симулирует солнце в игре_).

![](<image (23) (1).png>)

### Стены

Чтобы добавить новый объект на сцену нужно кликнуть правой кнопкой мыши в пустое место иерархии и выбрать какой именно объект хотим создать, в нашем случае **3D Object -> Cube**
После этого куб появится не только в иерархии, но и на сцене\
Чтобы приблизиться к нему нужно выбрать его в иерархии и наведя мышь на окно **Scene** нажать клавишу **F**

![](<image (22) (1).png>)

В данным момент выбран инструмент перемещения, который позволяет в помощью стрелок передвигать выбранный объект

Для изменения пропорций куба нужно выбрать инструмент **Scale** в верхней в части редактора

![](<image (13) (1).png>)

Теперь при зажатие стрелок куб не перемещается, а расширяется в определенную сторону

Создадим еще 3 куба и сделаем замкнутую стену

{% hint style="info" %}
Чтобы дублировать выбранный объект нужно нажать **Ctrl + D**
{% endhint %}

Для вращения используется инструмент **Rotate**

![](<image (1) (1).png>)

{% hint style="info" %}
Для поворота ровно на 15 градусов нужно зажать **Ctrl** во время вращения
{% endhint %}

Результат выглядит следующим образом:

![](<image (24) (1).png>)

### Пол

Осталось только добавить пол: создадим объект 3D Object -> Plane, масштабируем его и переместим в центр

![](<image (15) (1) (1).png>)
### Инспектор
Трансформировать объекты можно не только с помощью инструментов редактора, но и в окне инспектора

![](<image (43).png>)

Помимо **Transform** объекта мы видим также другие компоненты: **Renderer, Collider, Filter**. Для чего они нужны мы рассмотрим позже. Важно запомнить что Transform есть на любом объекте и его нельзя убрать.

> [!info] Компонент - составная часть объекта, которая добавляет ему определенные возможность

Также в верхней части инспектора можно изменить и имя объекта, чтобы не путаться в большом количестве кубов\
Изменим названия объектов на сцене следующим образом:

![](<image (12).png>)

### Сфера

Для начала добавим его на сцену **3D Object -> Sphere**

![](<image (18).png>)

Теперь поменяем ей цвет, для этого потребуется создать новый материал в окне **Project** - там хранятся все ресурсы нашей игры (_модели, материалы, скрипты_). Для этого нужно начать правой кнопкой в любом свободном месте окна и выбрать Create -> Material\
После этого он появится в списке ресурсов проекта:
![](<image (38).png>)

Выберем его и в Инспекторе поменяем цвет Albedo (_основная текстура_)

![](<image (3).png>)

Для применения материала просто перетащим его на шар

![](<image (16) (1) (1).png>)

Давайте рассмотрим набор компонентов сферы:

![](image.png)

- **Tranform** - находится на любом объекте и служит для изменения положения, вращения и масштаба объекта
- **Mesh Filter** и **Renderer** - необходимы для фильтрации и построения исходного набора полигонов, который есть у каждой 3D модели, а также наложения материала на нее
- **Sphere Collider** - коллайдеры служат для просчета столкновений объектов и не позволяют им заходить друг в друга. Префикс Sphere означает что коллайдер сферической формы.

Однако если запустить игру, то все объекты находятся на своих местах, ничего не падает по физике и не сталкивается.

Для работы **физики** в Unity на конкретном объекте есть компонент **Rigidbody** - он необходим для работы гравитации, столкновений, а также триггеров.\
Чтобы его добавить в списке компонентов нажмем на кнопку **Add Component**, найти его в списке и выбрать. После этого он окажется на объекте с настройками по умолчанию

![](<image (34) (1).png>)

![После запуска игры шар падает на пол под влиянием гравитации](<image (22).png>)

### Камера
Однако если перейди во вкладку **Game** можно увидеть что камера направлена совсем не на сцену\
Чтобы направить камеру на нашу сцену можно либо использовать использовать инструменты вращения и перемещения

![](<image (30).png>)

Либо же выровнять камеру в соответствии с обзором в окне Scene: для этого выберем камеру и в верхнем меню нажмем кнопку **Object -> Align With View**

После этого на вкладке **Game** обзор игрока будет следующим:

![](<image (33).png>)

### Цели для игрока

По примеру выше вы должны создать небольшой куб с материалом синего цвета

![](<image (15) (1).png>)

## Введение в программирование

### Функции жизненного цикла MonoBehaviour

Это функции, который вызывает сам **Unity** у всех классов, которые наследуются от **`MonoBehaviour`**

#### `Awake`
Всегда вызывается перед функцией **`Start`**
Обычно используется для настройки основных зависимостей (_если текущий скрипт использует другие компоненты_)

#### `Start`
Вызывается после загрузки сцены перед первым кадром
Обычно используется для задания стартовых значений параметров либо же трансформации (_перемещение, вращение, масштаб_)

#### `Update`
Вызывается один раз за кадр до обновления кадра - **привязан к производительности игры**\
Обычно используется для системы ввода и проверки значений в других скриптах благодаря чему минимизируются задержки в работе игры

> [!warning] Внимание
Не рекомендуется проводить дорогостоящие операции, такие как изменение физических параметров каждый кадр. Это оказывает значительное влияние на производительность

#### `FixedUpdate`
Вызывается каждый раз перед обновление физики - **почти не привязан к производительности** 
Рекомендуется перемещение и изменение физических свойств объекта переносить именно сюда для более корректно просчета

> [!info] На заметку
В **`FixedUpdate`** умножать скорость на **`Time.deltaTime`** не требуется, т.к. время между обновлением физики почти одинаково

#### `LateUpdate`

Вызывается перед отрисовкой кадра, но после всех функций обновления (**`Update`**, **`FixedUpdate`**)

#### `OnEnable`

Вызывается при включении текущего компонента и при старте игры, если компонент в этот момент включен.

#### `OnDisable`

Вызывается при выключении текущего компонента, объекта, уничтожении объекта или удалении компонента с него.

### Постоянное вращение целей

Для создания нового скрипта нужно нажать ПКМ в окне **Project -> Create -> C# Script** и перетащите его на объект или же нажать **Add Component** на объекте, ввести его название и нажать **New Script -> Create and Add.**

![Новый скрипт на объекте (цель для игрока)](<image (15).png>)

Чтобы открыть созданный скрипт можно просто дважды нажать на него.
По умолчанию он выглядит следующим образом:

```csharp
public class ConstantRotator : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {

    }

    // Update is called once per frame
    void Update()
    {

    }
}
```

Можно увидеть что был создал **C# класс**, который унаследован он **`MonoBehaviout`** - позволяет использовать методы жизненного цикла и добавлять скрипт на объект.

По умолчанию уже определено два метода жизненного цикла, которые являются приватными (`private`).

Теперь нужно реализовать постоянное вращение - бесконечно поворачивать объект на определенный угол.
Во вращение и перемещении нам помогает свойство **`transform`**, которое если у любого **`MonoBehaviout`**, которое позволяет получить доступ к компоненту **`Tranform`**.
Для вращения объекта используется метод **`Rotate`**, который принимает поворот в трех координатах - **X, Y, Z**. Просто добавим его в функцию **`Update`** и получим постоянное вращение.

```csharp
void Update()
    {
        transform.Rotate(0,0,5);
    }
```

### Вынос параметров скрипта в инспектор

Мы определи постоянное вращение в 5 градусов по оси Z, но что если геймдизайнер захочет изменить скорость или ось для вращения? Лезть в код и менять не вариант, ведь один и тот же скрипт может использоваться сразу на нескольких объектах

В Unity для скриптом можно указывать параметры, которые являются уникальными и способствуют повторному использованию уже написанных компонентов.
Для этого в классе нужно определить **публичное поле...**

```csharp
public Vector3 RotationSpeed;
```

**...** и Unity автоматически отобразит его в **Инспекторе** на компоненте

![](<image (27).png>)

Тип **`Vector3`** используется для задания значения по трем осям, каждое из которых представляет значение типа **`float`**.

Изменим код вращения, использовав поле **`RotationSpeed`**

```csharp
void Update()
{
    transform.Rotate(RotationSpeed);
}
```

Теперь у каждого объекта со скриптом **`ConstantRotator`** можно будет указать свою _уникальную_ скорость вращения.

### Трансформация объекта независимо от производительность

При постоянном изменении позиции или вращения объекта очень важно чтобы это происходило с одинаковой частотой, к примеру тут метод **`Update`** вызывается каждый кадр, из-за чего скорость вращения фактически привязана к производительности компьютера (_количеству кадров в секунду_) - чем больше кадров, тем быстрее вращается объект (_привет бегу в Fallout 76 или консольным играм заточенным под 30 FPS_).

Чтобы абстрагировать вращении или перемещение объекта от частоты кадров в секунду применяется несколько уловок:

#### `Time.deltaTime`

Изменять значения с той же частотой, но не на одинаковое значение, а привязать его в частоте кадров: при 60 вращать на 2.5 градуса, а при 30 на 5
Чтобы это реализовать нужно умножать скорость на время, прошедшее с предыдущего кадра (фактически время между кадрами, которое напрямую зависит от частоты их обновления).
**`Time.deltaTime`** - время, прошедшее с предыдущего вызова функции **`Update`**

```csharp
void Update()
{
    Vector3 fixedRotationSpeed = RotationSpeed * Time.deltaTime;
    transform.Rotate(fixedRotationSpeed);
}
```

#### `FixedUpdate`
Изменять значение с постоянной, фиксированной частотой - с помощью функции **`FixedUpdate`**.

```csharp
void FixedUpdate()
{
    transform.Rotate(RotationSpeed);
}
```

### Управление мячом
Создадим новый скрипт **BallController**, который будет отвечать за управление перемещением шара
Чтобы проверить нажата ли определенная кнопка используется функция **`Input.GetKey(KeyCode)`** которая принимает код элемента и возвращает **`true`**, если она прямо сейчас нажата

```csharp
private void Update()
    {
        if (Input.GetKey(KeyCode.UpArrow))
        {
            //действие, если стрелка вверх нажата
        }
    }
```

Проверку пользовательского ввода мы вставили в функцию **`Update`**, т.к. хотим добиться максимальной отзывчивости

Теперь нам нужно реализовать перемещение шара вперед при нажатии стрелки вверх
Для передвижения объекта используется метод **`Translate`** у объекта **`tranform`**, который принимает движение по трем координатам

```csharp
if (Input.GetKey(KeyCode.UpArrow))
{
    transform.Translate(0.1f, 0, 0);
}
```

Движение по вертикали будет изменять позицию по оси X, а по горизонтали - Z
Скопируем код для остальных элементов управления

```csharp
float speed = 0.1f;
if (Input.GetKey(KeyCode.UpArrow))
{
 transform.Translate(speed, 0, 0);
}
if (Input.GetKey(KeyCode.DownArrow))
{
 transform.Translate(-speed, 0, 0);
}
if (Input.GetKey(KeyCode.LeftArrow))
{
 transform.Translate(0, 0, speed);
}
if (Input.GetKey(KeyCode.RightArrow))
{
 transform.Translate(0, 0, -speed);
}
```

Получилось очень много операторов `if`, а если учитывать что вызывать мы будем это каждый кадр могут образоваться еще и проверки с производительностью

Хорошо что в Unity уже есть инструмент для работы с осями ввода - **`Input.GetAxis(axisName)`**. Эта функция принимает название оси и возвращает дробное число от **-1 до 1**
В качестве названия оси мы используем настроенные по умолчанию **Horizontal** и **Vertical** (**ввод по вертикали и горизонтали соответственно**)

```csharp
float horizontalInput = Input.GetAxis("Horizontal");
float verticalInput = Input.GetAxis("Vertical");
```

Таким образом мы сможем обрабатывать ввод не только с клавиатуры, но и с геймпада, т.к. оси ввода можно реализовать сразу для нескольких платформ

Теперь будем двигать шар по двум осям

```csharp
transform.Translate(verticalInput, 0, horizontalInput);
```

Однако теперь он двигается слишком быстро (если у вас много кадров в секунду) или наоборот. То есть его скорость привязана к количеству кадров\
Чтобы этого избежать умножим значения ввода на Time.deltaTime перед перемещением шара

```csharp
float fixedHorizontalInput = horizontalInput * Time.deltaTime;
float fixedVerticalInput = verticalInput * Time.deltaTime;
```

Теперь шар двигается корректно, но слишком медленно. Добавим поле **`Speed`** в наш скрипт, которое можно будет менять напрямую из **Инспектора** и умножим значения осей на скорость&#x20;

```csharp
public float Speed;
//...
float finalHorizontalOffset = fixedHorizontalInput * Speed;
float finalVerticalOffset = fixedVerticalInput * Speed;
```

В итоге скрипт выглядит следующим образом:

```csharp
public float Speed;
private void Update()
{
    float horizontalInput = Input.GetAxis("Horizontal");
    float verticalInput = Input.GetAxis("Vertical");
    float fixedHorizontalInput = horizontalInput * Time.deltaTime;
    float fixedVerticalInput = verticalInput * Time.deltaTime;
    float finalHorizontalOffset = fixedHorizontalInput * Speed;
    float finalVerticalOffset = fixedVerticalInput * Speed;
    transform.Translate(finalHorizontalOffset, 0, finalVerticalOffset);
}
```

### Триггеры

#### Создание триггера

Теперь нам нужно реализовать механику подбора (_уничтожения_) предмета при нахождении шара в коллайдере этого объекта

![](<image (35).png>)

Возможность проверять находится ли коллайдер одного в другом предоставляет нам триггер.
Для добавления триггера мы просто укажем галочку **IsTrigger** на компоненте **Collider** конкретного объекта

![](<image (7).png>)

#### Функции взаимодействия с триггерами

- **`OnTriggerEnter`** - вызывается при входе в триггер
- **`OnTriggerExit`** - вызывается при выходе из триггера
- **`OnTriggerStay`** - вызывается в каждый момент нахождения объекта в триггере

Все эти функции принимают **`Collider`**, который и является триггером

#### Подбор предметов с помощью триггера

Теперь мы можем в скрипте шара проверить вошел ли его коллайдер в триггер.\
Создадим новый скрипт **TriggerDestroyer** и добавим в него системную функцию **`OnTriggerEnter`**

```csharp
private void OnTriggerEnter(Collider other)
{
    //действие при входе в триггер
}
```

Теперь нам нужно уничтожить объект, в триггер которого мы вошли. В Unity уже есть функция Destroy, которая принимает цель для уничтожения

```csharp
Destroy(other.gameObject);
```

В данном случае мы получаем игровой объект через компонент коллайдера

#### Теги

Но бывают ситуации когда нам нужно взаимодействовать не со всеми триггера, а только с конкретными. Для таких ситуаций существуют теги - специальные тестовые метки, которые может иметь любой объект.
Изменим тег на нужный, если такого нет, то добавим его с помощью кнопки **AddTag**

![](<image (23).png>)

![](<image (4).png>)

Теперь добавим проверку на тег, вызвав у коллайдера функцию **`CompareTag`**, которая возвращает **`true`**, если на объекте он действительно есть

```csharp
if(other.CompareTag("Target"))
{
    //действие, если у объекта с триггером
    //"Target" установлен в качестве тега
}
```

Финальный код выглядит следующим образом:

```csharp
public class TriggerDestroyer : MonoBehaviour
{
    private void OnTriggerEnter(Collider other)
    {
        if(other.CompareTag("Target"))
        {
            Destroy(other.gameObject);
        }
    }
}
```
